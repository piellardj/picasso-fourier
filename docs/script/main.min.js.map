{"version":3,"sources":["webpack://picasso-fourier/./src/ts/canvas-2d.ts","webpack://picasso-fourier/./src/ts/clock.ts","webpack://picasso-fourier/./src/ts/fourier-series.ts","webpack://picasso-fourier/./src/ts/line-drawing.ts","webpack://picasso-fourier/./src/ts/log.ts","webpack://picasso-fourier/./src/ts/main.ts","webpack://picasso-fourier/./src/ts/parameters.ts","webpack://picasso-fourier/./src/ts/point.ts","webpack://picasso-fourier/./src/ts/presets.ts","webpack://picasso-fourier/./src/ts/stopwatch.ts","webpack://picasso-fourier/./src/ts/user-input.ts","webpack://picasso-fourier/webpack/bootstrap","webpack://picasso-fourier/webpack/startup"],"names":["TWO_PI","Math","PI","wantedLineWidth","isDrawingLine","nbPointsInLine","this","canvas","Page","Canvas","getCanvas","context","getContext","cssPixel","window","devicePixelRatio","viewportZoom","viewportCenter","x","y","precomputeTransformation","p","z","setFullViewport","width","height","lineWidth","style","strokeStyle","adjustSize","actualWidth","floor","clientWidth","actualHeight","clientHeight","clear","clearRect","drawCircle","center","radius","visibleRadius","scale","translateX","translateY","beginPath","arc","closePath","stroke","startLine","endLine","addPointToLine","point","moveTo","lineTo","download","filename","msToBlob","blob","navigator","msSaveBlob","toBlob","link","document","createElement","href","URL","createObjectURL","click","Canvas2D","speed","Parameters","paused","lastCheckpoint","clockTime","realTime","speedChangeObservers","push","updateSpeed","reset","performance","now","setSpeed","createCheckpoint","pause","resume","current","zoom","Clock","applyCoefficient","coefficient","t","currentPhase","n","phase","magnitude","cos","sin","applyCoefficientsArray","coefficients","totalLength","partialCurve","partialCurveOrder","length","Error","sort","a","b","absA","abs","absB","curveStepSize","curvePrecision","resetCurve","drawCurve","order","lastPointIndex","computePartialCurve","i","f","lastPoint","nextPoint","interpolatedPoint","Point","interpolate","drawCurvePartialOrder","additionalCoefficients","getCoefficients","nbSteps","localT","copy","drawSegmentsToPoint","drawCirclesToPoint","computePoint","missingCoefficients","currentPointIndex","nextPointIndex","ceil","neededCoefficients","orderFrom","orderTo","min","firstIndex","max","lastIndex","slice","FourierSeries","points","originalPathLength","distance","totalPathLength","firstPoint","equals","pathLength","originalPathDuration","draw","desiredLength","currentLength","segmentLength","interpolationFactor","finalPoint","computeFourierSeries","stopwatch","StopWatch","integrationPrecision","stepSize","dT","samples","iStep","desiredT","iPoint","exactPoint","two_pi_t","cx","cy","sample","TWO_PI_N_T","sqrt","atan2","Log","message","milliseconds","LineDrawing","enabled","setEnabled","e","m","console","log","setOrderIndicator","value","round","setIndicatorText","toLocaleString","canvas2D","downloadObservers","drawing","fourier","clock","needToRestart","clearObservers","UserInput","finishedAcquisitionCallbacks","isValid","showLoader","Presets","setCustomPreset","recordedPath","getSize","needToRedraw","loadPoints","loadPreset","canvasSize","getPreset","preset","redrawObservers","presetObservers","Observers","canvasResize","requestAnimationFrame","mainLoop","isRecording","resetZoom","drawCurrentPath","maxT","closeLoop","finishedLoop","isPaused","repeat","isProgressiveMode","persistence","displayOriginalCurve","displayCircles","displayCurve","displaySegments","smooth","main","EMode","controlId","callObservers","observersList","observer","mode","observers","tryParsePreset","previousValue","parseAndApplyMode","newModes","newMode","isInstant","INSTANT","Controls","setVisibility","Picker","addObserver","getValue","Tabs","getValues","Range","s","Checkbox","isChecked","checked","PROGRESSIVE","Button","o","updateZoom","updateIndicatorVisibility","visible","setIndicatorsVisibility","mouseWheel","delta","rawNewZoom","setValue","FileControl","addDownloadObserver","EPreset","CUSTOM","p1","p2","dX","dY","EState","PRESET_SIZE","wantedSize","callback","lastRegisteredCallback","wantedPreset","wantedWidth","wantedHeight","cache","state","LOADING","XMLHttpRequest","addEventListener","readyState","DONE","status","retrievedArray","tryParsePointsArray","responseText","LOADED","tryCallRegisteredCallback","open","send","scaling","stopWatchResize","resizedPreset","resizePreset","offsetX","offsetY","text","split","partial","start","currentPoints","isRecordingUserInput","getMousePosition","mousePosition","mouseDown","currentPosition","mouseUp","mouseMove","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["import { Point } from \"./point\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\n/**\r\n * Class for instancing and using a 2D HTML Canvas.\r\n */\r\nclass Canvas2D {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    private readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    private wantedLineWidth: number = 1;\r\n    private isDrawingLine: boolean = false;\r\n    private nbPointsInLine: number = 0;\r\n\r\n    private viewportZoom: number;\r\n    private viewportCenter: Point; // point that should be at the center of the viewport\r\n\r\n    private scale: number;\r\n    private translateX: number;\r\n    private translateY: number;\r\n\r\n    public constructor() {\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\");\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n\r\n        this.viewportZoom = 1;\r\n        this.viewportCenter = { x: 0, y: 0 };\r\n        this.precomputeTransformation();\r\n    }\r\n\r\n    public set center(p: Point) {\r\n        this.viewportCenter.x = p.x;\r\n        this.viewportCenter.y = p.y;\r\n        this.precomputeTransformation();\r\n    }\r\n\r\n    public set zoom(z: number) {\r\n        this.viewportZoom = z;\r\n        this.precomputeTransformation();\r\n    }\r\n\r\n    public setFullViewport(): void {\r\n        this.viewportZoom = 1;\r\n        this.viewportCenter.x = 0.5 * this.canvas.width / this.cssPixel;\r\n        this.viewportCenter.y = 0.5 * this.canvas.height / this.cssPixel;\r\n        this.precomputeTransformation();\r\n    }\r\n\r\n    public set lineWidth(width: number) {\r\n        this.wantedLineWidth = this.cssPixel * width;\r\n        this.context.lineWidth = this.wantedLineWidth;\r\n    }\r\n\r\n    public set strokeStyle(style: string) {\r\n        this.context.strokeStyle = style;\r\n    }\r\n\r\n    public adjustSize(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n            this.setFullViewport();\r\n        }\r\n    }\r\n\r\n    public clear(): void {\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    public drawCircle(center: Point, radius: number): void {\r\n        const visibleRadius = this.viewportZoom * radius;\r\n        const x = this.scale * center.x + this.translateX;\r\n        const y = this.scale * center.y + this.translateY;\r\n\r\n        if (visibleRadius > 0.5) {\r\n            this.context.beginPath();\r\n            this.context.arc(x, y, visibleRadius, 0, TWO_PI);\r\n            this.context.closePath();\r\n            this.context.stroke();\r\n        }\r\n    }\r\n\r\n    public startLine(): void {\r\n        if (this.isDrawingLine) {\r\n            this.endLine();\r\n        }\r\n\r\n        this.context.lineWidth = this.wantedLineWidth;\r\n        this.context.beginPath();\r\n        this.isDrawingLine = true;\r\n        this.nbPointsInLine = 0;\r\n    }\r\n\r\n    public addPointToLine(point: Point): void {\r\n        const x = this.scale * point.x + this.translateX;\r\n        const y = this.scale * point.y + this.translateY;\r\n\r\n        if (this.nbPointsInLine === 0) {\r\n            this.context.moveTo(x, y);\r\n        } else {\r\n            this.context.lineTo(x, y);\r\n        }\r\n\r\n        this.nbPointsInLine++;\r\n    }\r\n\r\n    public endLine(): void {\r\n        if (this.isDrawingLine) {\r\n            this.context.stroke();\r\n            this.context.closePath();\r\n            this.isDrawingLine = false;\r\n        }\r\n    }\r\n\r\n    public download(filename: string): void {\r\n        if ((this.canvas as any).msToBlob) { // for IE\r\n            const blob = (this.canvas as any).msToBlob();\r\n            window.navigator.msSaveBlob(blob, filename);\r\n        } else {\r\n            this.canvas.toBlob((blob: Blob | null) => {\r\n                if (blob !== null) {\r\n                    const link = document.createElement(\"a\");\r\n                    link.download = filename;\r\n                    link.href = URL.createObjectURL(blob);\r\n                    link.click();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private precomputeTransformation(): void {\r\n        this.scale = this.cssPixel * this.viewportZoom;\r\n        this.translateX = this.cssPixel * (-this.viewportZoom * this.viewportCenter.x) + 0.5 * this.canvas.width;\r\n        this.translateY = this.cssPixel * (-this.viewportZoom * this.viewportCenter.y) + 0.5 * this.canvas.height;\r\n    }\r\n}\r\n\r\nexport {\r\n    Canvas2D,\r\n};\r\n","import { Parameters } from \"./parameters\";\r\n\r\ninterface IClockCheckpoint {\r\n    clockTime: DOMHighResTimeStamp; // in the clock temporality\r\n    realTime: DOMHighResTimeStamp; // in the Javascript temporality\r\n}\r\n\r\n/**\r\n * This class handles the measuring of time at a variable speed.\r\n */\r\nclass Clock {\r\n    private speed: number;\r\n    private paused: boolean;\r\n\r\n    /* This checkpoint system is used to avoid floating point approximations when computing current time. */\r\n    private lastCheckpoint: IClockCheckpoint;\r\n\r\n    public constructor() {\r\n        this.speed = Parameters.speed;\r\n        this.paused = false;\r\n        this.lastCheckpoint = {\r\n            clockTime: 0,\r\n            realTime: 0,\r\n        };\r\n\r\n        Parameters.speedChangeObservers.push(() => this.updateSpeed());\r\n\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.paused = false;\r\n        this.lastCheckpoint.clockTime = 0;\r\n        this.lastCheckpoint.realTime = performance.now();\r\n        this.updateSpeed();\r\n    }\r\n\r\n    public setSpeed(speed: number): void {\r\n        this.createCheckpoint();\r\n        this.speed = speed;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.paused) {\r\n            this.createCheckpoint();\r\n            this.paused = true;\r\n        }\r\n    }\r\n\r\n    public resume(): void {\r\n        if (this.paused) {\r\n            this.createCheckpoint();\r\n            this.paused = false;\r\n        }\r\n    }\r\n\r\n    public get isPaused(): boolean {\r\n        return this.paused;\r\n    }\r\n\r\n    public get current(): DOMHighResTimeStamp {\r\n        if (this.paused) {\r\n            return this.lastCheckpoint.clockTime;\r\n        }\r\n\r\n        return this.lastCheckpoint.clockTime + this.speed * (performance.now() - this.lastCheckpoint.realTime);\r\n    }\r\n\r\n    private createCheckpoint(): void {\r\n        this.lastCheckpoint.clockTime = this.current;\r\n        this.lastCheckpoint.realTime = performance.now();\r\n    }\r\n\r\n    private updateSpeed(): void {\r\n        this.setSpeed(Parameters.speed / Parameters.zoom);\r\n    }\r\n}\r\n\r\nexport {\r\n    Clock,\r\n};\r\n","import { Canvas2D } from \"./canvas-2d\";\r\nimport { Parameters } from \"./parameters\";\r\nimport { Point} from \"./point\";\r\nimport { SpaceUnit, TimeUnit } from \"./units\";\r\n\r\ninterface IFourierCoefficient {\r\n    magnitude: number;\r\n    phase: number;\r\n    n: number;\r\n}\r\n\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\n/**\r\n * Modifies the point given as argument by applying to it the provided Fourier Coefficient at the provided location.\r\n */\r\nfunction applyCoefficient(point: Point, coefficient: IFourierCoefficient, t: TimeUnit): void {\r\n    const currentPhase = TWO_PI * t * coefficient.n + coefficient.phase;\r\n    point.x += coefficient.magnitude * Math.cos(currentPhase);\r\n    point.y += coefficient.magnitude * Math.sin(currentPhase);\r\n}\r\n\r\n/**\r\n * Modifies the point given as argument by applying to it the provided Fourier Coefficients at the provided location.\r\n */\r\nfunction applyCoefficientsArray(point: Point, coefficients: IFourierCoefficient[], t: TimeUnit): void {\r\n    for (const coefficient of coefficients) {\r\n        applyCoefficient(point, coefficient, t);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the Fourier development of a 1-periodic [0,1] -> RxR signal.\r\n * The 1D input is called Time (or t).\r\n * The 2D output is called Space.\r\n */\r\nclass FourierSeries {\r\n    private readonly coefficients: IFourierCoefficient[];\r\n    private readonly curveStepSize: SpaceUnit;\r\n\r\n    private partialCurve: Point[] = [];\r\n    private partialCurveOrder: number = -1;\r\n\r\n    public constructor(coefficients: IFourierCoefficient[], totalLength: SpaceUnit) {\r\n        if (coefficients.length % 2 !== 0) { // coefficients must go in pairs of 2: 0, 1, -1, 2, -2, ...\r\n            coefficients.length--;\r\n        }\r\n        if (coefficients.length === 0) {\r\n            throw new Error(\"Fourier series must have at least one coefficient.\");\r\n        }\r\n\r\n        // Sort the coefs in that order: 0, 1, -1, 2, -2, 3, -3, ...\r\n        coefficients.sort((a: IFourierCoefficient, b: IFourierCoefficient) => {\r\n            const absA = Math.abs(a.n);\r\n            const absB = Math.abs(b.n);\r\n            if (absA !== absB) {\r\n                return absA - absB;\r\n            }\r\n            return b.n - a.n;\r\n        });\r\n        this.coefficients = coefficients;\r\n\r\n        this.curveStepSize = 1 / (Parameters.curvePrecision * totalLength);\r\n    }\r\n\r\n    /**\r\n     * Purges the internal cache of the class. Should not be called too often.\r\n     */\r\n    public resetCurve(): void {\r\n        this.partialCurve = [];\r\n    }\r\n\r\n    /**\r\n     * Draws the [0, t] curve portion at the specified integer Fourier order.\r\n     * @param order Expected to be an integer\r\n     * @param t Expected to be in [0, 1]\r\n     */\r\n    public drawCurve(canvas: Canvas2D, order: number, t: TimeUnit): void {\r\n        const lastPointIndex = this.computePartialCurve(order, t);\r\n\r\n        // Draw partial curve\r\n        canvas.startLine();\r\n        for (let i = 0; i < lastPointIndex; i++) {\r\n            canvas.addPointToLine(this.partialCurve[i]);\r\n        }\r\n\r\n        const f = lastPointIndex % 1;\r\n        const lastPoint = this.partialCurve[Math.floor(lastPointIndex)];\r\n        const nextPoint = this.partialCurve[Math.floor(lastPointIndex) + 1];\r\n\r\n        const interpolatedPoint = Point.interpolate(lastPoint, nextPoint, f);\r\n        canvas.addPointToLine(interpolatedPoint);\r\n\r\n        canvas.endLine();\r\n    }\r\n\r\n    /**\r\n     * Draws the [0, approx. t] curve portion at the specified Fourier order.\r\n     * The order is linearily interpolated between the nearest coefficients.\r\n     * The curve's end (t parameter) is rounded to nearest.\r\n     * @param order If not an integer, then an intterpolation is performed to make sense of decimal Fourier order.\r\n     * @param t Expected to be in [0, 1]. Is not garanteed to be respected, approximations will be performed.\r\n     */\r\n    public drawCurvePartialOrder(canvas: Canvas2D, order: number, t: TimeUnit): void {\r\n        this.computePartialCurve(order, t);\r\n\r\n        let additionalCoefficients = this.getCoefficients(Math.floor(order) + 1, Math.floor(order) + 1);\r\n        let f = order % 1;\r\n        if (f < 0.5) {\r\n            additionalCoefficients = [additionalCoefficients[0]];\r\n            f *= 2;\r\n        } else {\r\n            f = 2 * f - 1;\r\n        }\r\n\r\n        canvas.startLine();\r\n\r\n        const nbSteps = t / this.curveStepSize;\r\n        for (let i = 0; i < nbSteps; i++) {\r\n            const localT = i * this.curveStepSize;\r\n\r\n            const nextPoint = Point.copy(this.partialCurve[i]);\r\n            applyCoefficient(nextPoint, additionalCoefficients[0], localT);\r\n\r\n            let lastPoint: Point;\r\n            if (additionalCoefficients.length === 1) {\r\n                lastPoint = this.partialCurve[i];\r\n            } else { // additionalCoefficients.length === 2\r\n                lastPoint = Point.copy(nextPoint);\r\n                applyCoefficient(nextPoint, additionalCoefficients[1], localT);\r\n            }\r\n\r\n            const interpolatedPoint = Point.interpolate(lastPoint, nextPoint, f);\r\n            canvas.addPointToLine(interpolatedPoint);\r\n        }\r\n\r\n        canvas.endLine();\r\n    }\r\n\r\n    /**\r\n     * Draws a path to the wanted point, in the form of segments representing the action of each coefficient.\r\n     * @param order Maximum Fourier order to use. Must be an integer.\r\n     *              Coefficients -order, -order+1, ..., 0, ..., +order will be used.\r\n     * @param t Expected to be in [0, 1]\r\n     */\r\n    public drawSegmentsToPoint(canvas: Canvas2D, order: number, t: TimeUnit): void {\r\n        const point: Point = { x: 0, y: 0 };\r\n\r\n        canvas.startLine();\r\n\r\n        const coefficients = this.getCoefficients(0, order);\r\n        for (const coefficient of coefficients) {\r\n            applyCoefficient(point, coefficient, t);\r\n            canvas.addPointToLine(point);\r\n        }\r\n\r\n        canvas.endLine();\r\n    }\r\n\r\n    /**\r\n     * Draws a path to the wanted point, in the form of circles representing the magnitude of each coefficient.\r\n     * @param order Maximum Fourier order to use. Must be an integer.\r\n     *              Coefficients -order, -order+1, ..., 0, ..., +order will be used.\r\n     * @param t Expected to be in [0, 1]\r\n     */\r\n    public drawCirclesToPoint(canvas: Canvas2D, order: number, t: TimeUnit): void {\r\n        const coefficients = this.getCoefficients(0, order);\r\n        if (coefficients.length < 2) {\r\n            return;\r\n        }\r\n\r\n        const point: Point = { x: 0, y: 0 };\r\n\r\n        for (const coefficient of coefficients) {\r\n            if (coefficient.n !== 0 && coefficient.n !== 1) {\r\n                canvas.drawCircle(point, coefficient.magnitude);\r\n            }\r\n            applyCoefficient(point, coefficient, t);\r\n        }\r\n    }\r\n\r\n    public computePoint(order: number, t: TimeUnit): Point {\r\n        const point: Point = { x: 0, y: 0 };\r\n        const coefficients = this.getCoefficients(0, order);\r\n        applyCoefficientsArray(point, coefficients, t);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Computes the partial curve between 0 and t in the given order.\r\n     * The partial curve serves as cache and is as reused as possible.\r\n     * Returns the index of the 't' point in the partial curve.\r\n     * If this index is not an integer, it means an interpolation should be performed.\r\n     */\r\n    private computePartialCurve(order: number, t: TimeUnit): number {\r\n        order = Math.floor(order);\r\n\r\n        if (order < this.partialCurveOrder) {\r\n            // Existing points are computed with too high order. Restart from scratch.\r\n            this.resetCurve();\r\n        } else if (order > this.partialCurveOrder) {\r\n            // Existing points are computed with too low order. Complete existing points with missing orders.\r\n            const missingCoefficients = this.getCoefficients(this.partialCurveOrder + 1, order);\r\n\r\n            for (let i = 0; i < this.partialCurve.length; i++) {\r\n                const localT = i * this.curveStepSize;\r\n                applyCoefficientsArray(this.partialCurve[i], missingCoefficients, localT);\r\n            }\r\n        }\r\n\r\n        // Compute new points if needed\r\n        const currentPointIndex = t / this.curveStepSize;\r\n        const nextPointIndex = Math.ceil(currentPointIndex);\r\n\r\n        const neededCoefficients = this.getCoefficients(0, order);\r\n        for (let i = this.partialCurve.length; i <= nextPointIndex + 1; i++) {\r\n            const point: Point = { x: 0, y: 0 };\r\n            applyCoefficientsArray(point, neededCoefficients, i * this.curveStepSize);\r\n            this.partialCurve.push(point);\r\n        }\r\n\r\n        this.partialCurveOrder = order;\r\n        return currentPointIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of coefficients containing, in that order:\r\n     * if orderFrom > 0: orderFrom, -orderFrom, orderFrom+1, -(orderFrom+1), ..., orderTo, -orderTo\r\n     * if orderFrom == 0: 0, 1, -1, ... orderTo, -orderTo\r\n     * If orderFrom > orderTo, or if one of the parameters is out of range, only returns the valid coefficients.\r\n     */\r\n    private getCoefficients(orderFrom: number, orderTo: number): IFourierCoefficient[] {\r\n        orderFrom = Math.min(orderFrom, orderTo);\r\n\r\n        const firstIndex = Math.max(0, 2 * orderFrom - 1);\r\n        const lastIndex = Math.min(this.coefficients.length, 2 * orderTo + 1);\r\n\r\n        return this.coefficients.slice(firstIndex, lastIndex);\r\n    }\r\n}\r\n\r\nexport {\r\n    IFourierCoefficient,\r\n    FourierSeries,\r\n};\r\n","import { Canvas2D } from \"./canvas-2d\";\r\nimport { FourierSeries, IFourierCoefficient } from \"./fourier-series\";\r\nimport * as Log from \"./log\";\r\nimport { Parameters } from \"./parameters\";\r\nimport { Point } from \"./point\";\r\nimport { StopWatch } from \"./stopwatch\";\r\nimport { SpaceUnit, TimeUnit } from \"./units\";\r\n\r\n/**\r\n * Represents a 2D line parametrized by a 1D input.\r\n * The line is 1-periodic: [0,1] -> RxR.\r\n * The 1D input is called Time (or t).\r\n * The 2D output is called Space.\r\n */\r\nclass LineDrawing {\r\n    public readonly pathLength: SpaceUnit; // Length of the total path in space-units\r\n    public readonly originalPathDuration: TimeUnit; // Length of the original path in time-units\r\n    private readonly points: Point[];\r\n\r\n    /**\r\n     * Builds a LineDrawing from the input points.\r\n     * If the input is not periodic, then we extend it with a last point to make the LineDrawing periodic.\r\n     */\r\n    public constructor(points: Point[]) {\r\n        this.points = points;\r\n\r\n        let originalPathLength: SpaceUnit = 0;\r\n        for (let i = 0; i < this.points.length - 1; i++) {\r\n            originalPathLength += Point.distance(this.points[i], this.points[i + 1]);\r\n        }\r\n\r\n        let totalPathLength: SpaceUnit = originalPathLength;\r\n\r\n        // For Fourier series computing, artificially make the path periodic\r\n        const firstPoint = this.points[0];\r\n        const lastPoint = this.points[this.points.length - 1];\r\n        if (!Point.equals(firstPoint, lastPoint)) {\r\n            totalPathLength += Point.distance(lastPoint, firstPoint);\r\n            this.points.push(Point.copy(firstPoint));\r\n        }\r\n\r\n        this.pathLength = totalPathLength;\r\n        this.originalPathDuration = originalPathLength / totalPathLength;\r\n    }\r\n\r\n    /**\r\n     * Draws the line portion between 0 and t.\r\n     * @param t Expected to be in [0, 1]\r\n     */\r\n    public draw(canvas: Canvas2D, t: TimeUnit): void {\r\n        const desiredLength: SpaceUnit = t * this.pathLength;\r\n        let currentLength: SpaceUnit = 0;\r\n\r\n        canvas.startLine();\r\n        canvas.addPointToLine(this.points[0]);\r\n\r\n        for (let i = 0; i < this.points.length - 1; i++) {\r\n            const lastPoint = this.points[i];\r\n            const nextPoint = this.points[i + 1];\r\n            const segmentLength = Point.distance(lastPoint, nextPoint);\r\n\r\n            if (currentLength + segmentLength < desiredLength) {\r\n                currentLength += segmentLength;\r\n                canvas.addPointToLine(nextPoint);\r\n            } else {\r\n                const interpolationFactor = (desiredLength - currentLength) / segmentLength;\r\n                const finalPoint = Point.interpolate(lastPoint, nextPoint, interpolationFactor);\r\n                canvas.addPointToLine(finalPoint);\r\n                break;\r\n            }\r\n        }\r\n\r\n        canvas.endLine();\r\n    }\r\n\r\n    public computeFourierSeries(order: number): FourierSeries {\r\n        const stopwatch = new StopWatch();\r\n\r\n        const nbSteps = Math.max(200, Math.ceil(Parameters.integrationPrecision * this.pathLength));\r\n        const stepSize = this.pathLength / nbSteps;\r\n        const dT = 1 / nbSteps;\r\n\r\n        /* Precompute function samples to avoid computing them for each coefficient. */\r\n        interface IFunctionSample {\r\n            x: number;\r\n            y: number;\r\n            two_pi_t: number; // t is where the drawing was evaluated\r\n        }\r\n\r\n        const samples: IFunctionSample[] = [];\r\n        {\r\n            let currentLength = 0;\r\n            let lastPointIndex = 0;\r\n            for (let iStep = 0; iStep < nbSteps; iStep++) {\r\n                const desiredT = (iStep + 0.5) * dT;\r\n                const desiredLength = (iStep + 0.5) * stepSize;\r\n\r\n                for (let iPoint = lastPointIndex; iPoint < this.points.length - 1; iPoint++) {\r\n                    const lastPoint = this.points[iPoint];\r\n                    const nextPoint = this.points[iPoint + 1];\r\n                    const segmentLength = Point.distance(lastPoint, nextPoint);\r\n\r\n                    if (currentLength + segmentLength < desiredLength) {\r\n                        currentLength += segmentLength;\r\n                        lastPointIndex = iPoint + 1;\r\n                    } else {\r\n                        const interpolationFactor = (desiredLength - currentLength) / segmentLength;\r\n                        const exactPoint = Point.interpolate(lastPoint, nextPoint, interpolationFactor);\r\n                        samples.push({\r\n                            x: exactPoint.x,\r\n                            y: exactPoint.y,\r\n                            two_pi_t: 2 * Math.PI * desiredT,\r\n                        });\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const coefficients: IFourierCoefficient[] = [];\r\n        for (let i = 0; i < 2 * order + 1; i++) {\r\n            let n = Math.floor((i + 1) / 2); // n is the index of the coefficient we're about to compute\r\n            if (i > 0 && i % 2 === 0) {\r\n                n *= -1;\r\n            }\r\n\r\n            let cx = 0;\r\n            let cy = 0;\r\n            for (const sample of samples) {\r\n                const TWO_PI_N_T = n * sample.two_pi_t;\r\n                const cos = Math.cos(TWO_PI_N_T);\r\n                const sin = Math.sin(TWO_PI_N_T);\r\n\r\n                cx += dT * (sample.x * cos + sample.y * sin);\r\n                cy += dT * (sample.y * cos - sample.x * sin);\r\n            }\r\n\r\n            coefficients.push({\r\n                magnitude: Math.sqrt(cx * cx + cy * cy),\r\n                phase: Math.atan2(cy, cx),\r\n                n,\r\n            });\r\n        }\r\n\r\n        Log.message(`Computed ${order} Fourier coefficient with ${nbSteps} integration steps ` +\r\n            `in ${stopwatch.milliseconds} ms.`);\r\n        return new FourierSeries(coefficients, this.pathLength);\r\n    }\r\n}\r\n\r\nexport {\r\n    LineDrawing,\r\n};\r\n","let enabled = true;\r\n\r\nfunction setEnabled(e: boolean): void {\r\n    enabled = e;\r\n}\r\n\r\nfunction message(m: string): void {\r\n    if (enabled) {\r\n        console.log(m);\r\n    }\r\n}\r\n\r\nexport {\r\n    setEnabled,\r\n    message,\r\n};\r\n","import { Canvas2D } from \"./canvas-2d\";\r\nimport { Clock } from \"./clock\";\r\nimport { FourierSeries } from \"./fourier-series\";\r\nimport { LineDrawing } from \"./line-drawing\";\r\nimport { Parameters } from \"./parameters\";\r\nimport { Point } from \"./point\";\r\nimport { Presets } from \"./presets\";\r\nimport { TimeUnit } from \"./units\";\r\nimport * as UserInput from \"./user-input\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction setOrderIndicator(value: number): void {\r\n    value = Math.round(100 * value) / 100; // 2 digits max\r\n    Page.Canvas.setIndicatorText(\"fourier-order\", value.toLocaleString());\r\n}\r\n\r\nfunction main(): void {\r\n    const canvas2D = new Canvas2D();\r\n    canvas2D.lineWidth = 1;\r\n\r\n    Parameters.downloadObservers.push(() => canvas2D.download(\"picasso-fourier.png\"));\r\n\r\n    let drawing: LineDrawing = null;\r\n    let fourier: FourierSeries = null;\r\n\r\n    const clock = new Clock();\r\n\r\n    let needToRestart = true;\r\n    Parameters.clearObservers.push(() => needToRestart = true);\r\n    UserInput.finishedAcquisitionCallbacks.push((isValid: boolean) => {\r\n        if (isValid) {\r\n            drawing = null;\r\n            fourier = null;\r\n            Page.Canvas.showLoader(true);\r\n\r\n            Presets.setCustomPreset(UserInput.recordedPath, Page.Canvas.getSize());\r\n            Parameters.setCustomPreset();\r\n        }\r\n        needToRedraw = true;\r\n    });\r\n\r\n    let needToRedraw = true;\r\n    Parameters.redrawObservers.push(() => needToRedraw = true);\r\n\r\n    function loadPoints(points: Point[]): void {\r\n        drawing = new LineDrawing(points);\r\n        fourier = drawing.computeFourierSeries(300 + 1); // one more to avoid out of bounds exceptions\r\n        needToRestart = true;\r\n        clock.reset();\r\n        Page.Canvas.showLoader(false);\r\n    }\r\n\r\n    function loadPreset(): void {\r\n        drawing = null;\r\n        fourier = null;\r\n\r\n        const canvasSize: number[] = Page.Canvas.getSize();\r\n        Page.Canvas.showLoader(true);\r\n        Presets.getPreset(Parameters.preset, canvasSize, loadPoints);\r\n    }\r\n\r\n    Parameters.presetObservers.push(loadPreset);\r\n    Page.Canvas.Observers.canvasResize.push(loadPreset);\r\n\r\n    const loopDuration = 2000; // milliseconds, at normal speed\r\n    function mainLoop(): void {\r\n        if (UserInput.isRecording()) {\r\n            canvas2D.clear();\r\n            canvas2D.setFullViewport();\r\n            Parameters.resetZoom();\r\n            canvas2D.strokeStyle = \"white\";\r\n            UserInput.drawCurrentPath(canvas2D);\r\n        } else if (drawing !== null && fourier !== null) { // checks that preset is loaded\r\n            let t: TimeUnit = clock.current / loopDuration;\r\n            const maxT: TimeUnit = Parameters.closeLoop ? 1 : drawing.originalPathDuration;\r\n            let finishedLoop = (t >= maxT);\r\n\r\n            if (!finishedLoop && clock.isPaused) {\r\n                clock.resume();\r\n            }\r\n\r\n            t = Math.min(t, maxT);\r\n\r\n            if (finishedLoop) {\r\n                if (Parameters.repeat) {\r\n                    needToRestart = true;\r\n                } else {\r\n                    clock.pause();\r\n                }\r\n            }\r\n\r\n            if (needToRestart) {\r\n                if (Parameters.isProgressiveMode) {\r\n                    Parameters.resetZoom();\r\n                }\r\n\r\n                needToRestart = false;\r\n                clock.reset();\r\n                fourier.resetCurve();\r\n                t = 0;\r\n                finishedLoop = false;\r\n                setOrderIndicator(Parameters.order);\r\n                canvas2D.clear();\r\n            }\r\n\r\n            if (needToRedraw) {\r\n                canvas2D.adjustSize();\r\n\r\n                if (Parameters.isProgressiveMode || Parameters.zoom === 1) {\r\n                    canvas2D.setFullViewport();\r\n                } else {\r\n                    canvas2D.zoom = Parameters.zoom;\r\n                    canvas2D.center = fourier.computePoint(Parameters.order, t);\r\n                }\r\n\r\n                if (!Parameters.persistence) {\r\n                    canvas2D.clear();\r\n                }\r\n\r\n                if (Parameters.displayOriginalCurve) {\r\n                    canvas2D.strokeStyle = \"rgb(0,128,0)\";\r\n                    canvas2D.lineWidth = 3;\r\n                    drawing.draw(canvas2D, Parameters.isProgressiveMode ? maxT : t);\r\n                    canvas2D.lineWidth = 1;\r\n                }\r\n\r\n                if (Parameters.displayCircles) {\r\n                    canvas2D.strokeStyle = Parameters.persistence ? \"rgba(255,255,255,0.01)\" : \"rgba(255,255,255,0.3)\";\r\n                    fourier.drawCirclesToPoint(canvas2D, Parameters.order, t);\r\n                }\r\n\r\n                if (Parameters.displayCurve) {\r\n                    canvas2D.strokeStyle = \"white\";\r\n                    fourier.drawCurve(canvas2D, Parameters.order, t);\r\n                }\r\n\r\n                if (Parameters.displaySegments) {\r\n                    canvas2D.strokeStyle = Parameters.persistence ? \"rgba(255,0,0,0.01)\" : \"red\";\r\n                    fourier.drawSegmentsToPoint(canvas2D, Parameters.order, t);\r\n                }\r\n\r\n                if (Parameters.isProgressiveMode) {\r\n                    let order = Parameters.order * t / maxT;\r\n\r\n                    if (!Parameters.persistence) {\r\n                        canvas2D.strokeStyle = \"white\";\r\n                    } else if (Parameters.smooth) {\r\n                        canvas2D.strokeStyle = \"rgba(255,255,255,0.01)\";\r\n                    } else {\r\n                        canvas2D.strokeStyle = \"rgba(255,255,255,0.03)\";\r\n                    }\r\n\r\n                    if (!Parameters.smooth) {\r\n                        order = Math.floor(order);\r\n                        fourier.drawCurve(canvas2D, order, maxT);\r\n                    } else {\r\n                        fourier.drawCurvePartialOrder(canvas2D, order, maxT);\r\n                    }\r\n\r\n                    setOrderIndicator(order);\r\n                }\r\n            }\r\n\r\n            needToRedraw = !finishedLoop && Parameters.speed > 0;\r\n        }\r\n\r\n        requestAnimationFrame(mainLoop);\r\n    }\r\n\r\n    loadPreset();\r\n    requestAnimationFrame(mainLoop);\r\n}\r\n\r\nmain();\r\n","import { EPreset } from \"./presets\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\n/* === IDs ============================================================ */\r\nconst controlId = {\r\n    PRESET: \"preset-picker-id\",\r\n    MODE: \"mode-picker-id\",\r\n    SPEED: \"speed-range-id\",\r\n    PERSISTENCE: \"persistence-checkbox-id\",\r\n    SMOOTH: \"smooth-checkbox-id\",\r\n    CLOSE_LOOP: \"close-loop-checkbox-id\",\r\n    REPEAT: \"loop-checkbox-id\",\r\n    RESET: \"reset-button-id\",\r\n    DISPLAY_CIRCLES: \"circles-checkbox-id\",\r\n    DISPLAY_SEGMENTS: \"segments-checkbox-id\",\r\n    DISPLAY_CURVE: \"curve-checkbox-id\",\r\n    DISPLAY_ORIGINAL_CURVE: \"original-curve-checkbox-id\",\r\n    ORDER: \"order-range-id\",\r\n    ZOOM: \"zoom-range-id\",\r\n    INDICATOR: \"indicator-checkbox-id\",\r\n    DOWNLOAD: \"download-button-id\",\r\n};\r\n\r\nenum EMode {\r\n    INSTANT = \"0\",\r\n    PROGRESSIVE = \"1\",\r\n}\r\n\r\n/* === OBSERVERS ====================================================== */\r\ntype GenericObserver = () => void;\r\n\r\nfunction callObservers(observersList: GenericObserver[]): void {\r\n    for (const observer of observersList) {\r\n        observer();\r\n    }\r\n}\r\n\r\nconst observers: {\r\n    clear: GenericObserver[];\r\n    redraw: GenericObserver[];\r\n    speedChange: GenericObserver[];\r\n    presetChange: GenericObserver[];\r\n    download: GenericObserver[];\r\n} = {\r\n    clear: [],\r\n    redraw: [],\r\n    speedChange: [],\r\n    presetChange: [],\r\n    download: [],\r\n};\r\n\r\n/* === EVENTS BINDING ================================================= */\r\n\r\n/* --- PARAMETERS ----------------------------------------------------- */\r\nlet preset: EPreset;\r\nfunction tryParsePreset(p: string): void {\r\n    const previousValue = preset;\r\n    preset = p as EPreset;\r\n\r\n    if (preset !== previousValue) {\r\n        callObservers(observers.presetChange);\r\n    }\r\n}\r\nPage.Picker.addObserver(controlId.PRESET, tryParsePreset);\r\ntryParsePreset(Page.Picker.getValue(controlId.PRESET));\r\n\r\nlet mode: EMode;\r\nfunction parseAndApplyMode(newModes: string[]): void {\r\n    if (newModes.length !== 1) {\r\n        return;\r\n    }\r\n\r\n    const newMode = newModes[0] as EMode;\r\n    if (newMode !== mode) {\r\n        mode = newMode;\r\n\r\n        const isInstant = (mode === EMode.INSTANT);\r\n        Page.Controls.setVisibility(controlId.SMOOTH, !isInstant);\r\n        Page.Controls.setVisibility(controlId.DISPLAY_CIRCLES, isInstant);\r\n        Page.Controls.setVisibility(controlId.DISPLAY_SEGMENTS, isInstant);\r\n        Page.Controls.setVisibility(controlId.DISPLAY_CURVE, isInstant);\r\n        Page.Controls.setVisibility(controlId.ZOOM, isInstant);\r\n\r\n        callObservers(observers.clear);\r\n    }\r\n}\r\nparseAndApplyMode(Page.Tabs.getValues(controlId.MODE));\r\nPage.Tabs.addObserver(controlId.MODE, parseAndApplyMode);\r\n\r\nlet speed: number = Page.Range.getValue(controlId.SPEED);\r\nPage.Range.addObserver(controlId.SPEED, (s: number) => {\r\n    speed = s;\r\n    callObservers(observers.speedChange);\r\n});\r\n\r\nlet persistence: boolean = Page.Checkbox.isChecked(controlId.PERSISTENCE);\r\nPage.Checkbox.addObserver(controlId.PERSISTENCE, (checked: boolean) => {\r\n    persistence = checked;\r\n});\r\n\r\nlet smooth: boolean = Page.Checkbox.isChecked(controlId.SMOOTH);\r\nPage.Checkbox.addObserver(controlId.SMOOTH, (checked: boolean) => {\r\n    smooth = checked;\r\n});\r\n\r\nlet closeLoop: boolean = Page.Checkbox.isChecked(controlId.CLOSE_LOOP);\r\nPage.Checkbox.addObserver(controlId.CLOSE_LOOP, (checked: boolean) => {\r\n    closeLoop = checked;\r\n\r\n    if (mode === EMode.PROGRESSIVE) {\r\n        callObservers(observers.clear);\r\n    }\r\n});\r\n\r\nlet repeat: boolean = Page.Checkbox.isChecked(controlId.REPEAT);\r\nPage.Checkbox.addObserver(controlId.REPEAT, (checked: boolean) => {\r\n    repeat = checked;\r\n});\r\n\r\nPage.Button.addObserver(controlId.RESET, () => callObservers(observers.clear));\r\n\r\nlet displayCircles: boolean = Page.Checkbox.isChecked(controlId.DISPLAY_CIRCLES);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_CIRCLES, (checked: boolean) => {\r\n    displayCircles = checked;\r\n    callObservers(observers.redraw);\r\n});\r\n\r\nlet displaySegments: boolean = Page.Checkbox.isChecked(controlId.DISPLAY_SEGMENTS);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_SEGMENTS, (checked: boolean) => {\r\n    displaySegments = checked;\r\n    callObservers(observers.redraw);\r\n});\r\n\r\nlet displayCurve: boolean = Page.Checkbox.isChecked(controlId.DISPLAY_CURVE);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_CURVE, (checked: boolean) => {\r\n    displayCurve = checked;\r\n    callObservers(observers.redraw);\r\n});\r\n\r\nlet displayOriginalCurve: boolean = Page.Checkbox.isChecked(controlId.DISPLAY_ORIGINAL_CURVE);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_ORIGINAL_CURVE, (checked: boolean) => {\r\n    displayOriginalCurve = checked;\r\n    callObservers(observers.redraw);\r\n});\r\n\r\nlet order: number = Page.Range.getValue(controlId.ORDER);\r\nPage.Range.addObserver(controlId.ORDER, (o: number) => {\r\n    order = o;\r\n    callObservers(observers.clear);\r\n});\r\n\r\nlet zoom: number = Page.Range.getValue(controlId.ZOOM);\r\nfunction updateZoom(z: number): void {\r\n    zoom = z;\r\n    callObservers(observers.redraw);\r\n    callObservers(observers.speedChange);\r\n}\r\nPage.Range.addObserver(controlId.ZOOM, updateZoom);\r\nPage.Canvas.Observers.mouseWheel.push((delta: number) => {\r\n    const rawNewZoom = zoom * (1 + 0.1 * delta);\r\n    console.log(`${zoom}  -  ${rawNewZoom}`);\r\n    Page.Range.setValue(controlId.ZOOM, rawNewZoom);\r\n    updateZoom(Page.Range.getValue(controlId.ZOOM));\r\n    console.log(Page.Range.getValue(controlId.ZOOM));\r\n});\r\n\r\nfunction updateIndicatorVisibility(): void {\r\n    const visible = Page.Checkbox.isChecked(controlId.INDICATOR);\r\n    Page.Canvas.setIndicatorsVisibility(visible);\r\n}\r\nupdateIndicatorVisibility();\r\nPage.Checkbox.addObserver(controlId.INDICATOR, updateIndicatorVisibility);\r\n\r\nPage.FileControl.addDownloadObserver(controlId.DOWNLOAD, () => callObservers(observers.download));\r\n\r\n/* === INTERFACE ====================================================== */\r\n/**\r\n * Class giving access to all the parameters of the application. Also gives access to event handlers.\r\n */\r\nclass Parameters {\r\n    public static get preset(): EPreset {\r\n        return preset;\r\n    }\r\n    public static setCustomPreset(): void {\r\n        Page.Picker.setValue(controlId.PRESET, null);\r\n        preset = EPreset.CUSTOM;\r\n        callObservers(observers.presetChange);\r\n    }\r\n\r\n    public static get isProgressiveMode(): boolean {\r\n        return mode === EMode.PROGRESSIVE;\r\n    }\r\n\r\n    public static get speed(): number {\r\n        if (this.isProgressiveMode) {\r\n            return 0.1 * speed;\r\n        }\r\n        return speed;\r\n    }\r\n\r\n    public static get persistence(): boolean {\r\n        return persistence;\r\n    }\r\n\r\n    public static get smooth(): boolean {\r\n        return smooth;\r\n    }\r\n\r\n    public static get closeLoop(): boolean {\r\n        return closeLoop;\r\n    }\r\n\r\n    public static get repeat(): boolean {\r\n        return repeat;\r\n    }\r\n\r\n    public static get displayCircles(): boolean {\r\n        return mode === EMode.INSTANT && displayCircles;\r\n    }\r\n\r\n    public static get displaySegments(): boolean {\r\n        return mode === EMode.INSTANT && displaySegments;\r\n    }\r\n\r\n    public static get displayCurve(): boolean {\r\n        return mode === EMode.INSTANT && displayCurve;\r\n    }\r\n\r\n    public static get displayOriginalCurve(): boolean {\r\n        return displayOriginalCurve;\r\n    }\r\n\r\n    public static get order(): number {\r\n        return order;\r\n    }\r\n\r\n    public static get zoom(): number {\r\n        return zoom;\r\n    }\r\n    public static resetZoom(): void {\r\n        zoom = 1;\r\n        Page.Range.setValue(controlId.ZOOM, zoom);\r\n    }\r\n\r\n    public static get integrationPrecision(): number {\r\n        const integrationStepSize = 1; // one space-unit per integration step\r\n        return 1 / integrationStepSize;\r\n    }\r\n\r\n    public static get curvePrecision(): number {\r\n        const stepSize = 2; // sampling every two space-units\r\n        return 1 / stepSize;\r\n    }\r\n\r\n    public static get clearObservers(): GenericObserver[] {\r\n        return observers.clear;\r\n    }\r\n    public static get redrawObservers(): GenericObserver[] {\r\n        return observers.redraw;\r\n    }\r\n    public static get speedChangeObservers(): GenericObserver[] {\r\n        return observers.speedChange;\r\n    }\r\n    public static get presetObservers(): GenericObserver[] {\r\n        return observers.presetChange;\r\n    }\r\n    public static get downloadObservers(): GenericObserver[] {\r\n        return observers.download;\r\n    }\r\n\r\n    private constructor() { }\r\n}\r\n\r\nexport {\r\n    Parameters,\r\n};\r\n","/**\r\n * Simple data class representing a 2D point.\r\n */\r\nclass Point {\r\n    /* Assumes t is between 0 and 1 included. */\r\n    public static interpolate(p1: Point, p2: Point, t: number): Point {\r\n        return {\r\n            x: p1.x * (1 - t) + p2.x * t,\r\n            y: p1.y * (1 - t) + p2.y * t,\r\n        };\r\n    }\r\n\r\n    public static distance(p1: Point, p2: Point): number {\r\n        const dX = p1.x - p2.x;\r\n        const dY = p1.y - p2.y;\r\n        return Math.sqrt(dX * dX + dY * dY);\r\n    }\r\n\r\n    public static equals(p1: Point, p2: Point): boolean {\r\n        return p1.x === p2.x && p1.y === p2.y;\r\n    }\r\n\r\n    public static copy(point: Point): Point {\r\n        return {\r\n            x: point.x,\r\n            y: point.y,\r\n        };\r\n    }\r\n\r\n    public x: number;\r\n    public y: number;\r\n}\r\n\r\nexport {\r\n    Point,\r\n};\r\n","import * as Log from \"./log\";\r\nimport { Point } from \"./point\";\r\nimport { StopWatch } from \"./stopwatch\";\r\n\r\n/* Enum values must match the values of the controls */\r\nenum EPreset {\r\n    ARLEQUIN1 = \"arlequin1\",\r\n    ARLEQUIN2 = \"arlequin2\",\r\n    BULL = \"bull\",\r\n    CAMEL = \"camel\",\r\n    CUSTOM = \"<none>\", // not available via interface\r\n    DOG = \"dog\",\r\n    DOVE = \"dove\",\r\n    FLAMINGO = \"flamingo\",\r\n    HORSE = \"horse\",\r\n    MOUSE = \"mouse\",\r\n    PENGUIN = \"penguin\",\r\n    WOMAN1 = \"woman1\",\r\n    WOMAN2 = \"woman2\",\r\n}\r\n\r\nconst PRESET_SIZE = 512; // a preset should be dimensionned for a 512 x 512 canvas\r\n\r\nenum EState {\r\n    LOADING,\r\n    LOADED,\r\n}\r\n\r\ninterface ICachedPreset {\r\n    state: EState;\r\n    points: Point[];\r\n}\r\n\r\ntype PresetCallback = (array: Point[]) => unknown;\r\n\r\n/**\r\n * Class for retrieving on demand the preset drawings with AJAX requests.\r\n * Tries to minimize the request by using a memory cache.\r\n */\r\nclass Presets {\r\n    /* Pending callbacks (waiting on preset loading for instance) will be cancelled */\r\n    public static getPreset(preset: EPreset, wantedSize: number[], callback: PresetCallback): void {\r\n        // erase previously registered callbacks\r\n        Presets.lastRegisteredCallback = {\r\n            wantedPreset: preset,\r\n            wantedWidth: wantedSize[0],\r\n            wantedHeight: wantedSize[1],\r\n            callback,\r\n        };\r\n\r\n        if (typeof Presets.cache[preset] === \"undefined\") { // preset never requested before\r\n            Presets.cache[preset] = {\r\n                state: EState.LOADING,\r\n                points: [],\r\n            };\r\n\r\n            const stopWatchDownload = new StopWatch();\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.addEventListener(\"readystatechange\", () => {\r\n                if (xhr.readyState === XMLHttpRequest.DONE) {\r\n                    if (xhr.status === 200) {\r\n                        Log.message(`Downloaded preset '${preset}' in ${stopWatchDownload.milliseconds} ms`);\r\n\r\n                        const retrievedArray = Presets.tryParsePointsArray(xhr.responseText);\r\n\r\n                        if (retrievedArray !== null) {\r\n                            Presets.cache[preset].points = retrievedArray;\r\n                            Presets.cache[preset].state = EState.LOADED;\r\n                            Presets.tryCallRegisteredCallback();\r\n                        } else {\r\n                            Log.message(`Failed to parse download preset '${preset}'`);\r\n                        }\r\n                    } else {\r\n                        Log.message(`Failed to download preset '${preset}'`);\r\n                    }\r\n                }\r\n            });\r\n            xhr.open(\"GET\", `resources/${preset}.txt`);\r\n            xhr.send();\r\n        } else {\r\n            Presets.tryCallRegisteredCallback(); // maybe the preset is ready\r\n        }\r\n    }\r\n\r\n    public static setCustomPreset(points: Point[], canvasSize: number[]): void {\r\n        // Scale path to a PRESET_SIZE*PRESET_SIZE canvas.\r\n        // Depending on canvas aspect ratio it may not fit but it doesn't matter\r\n        const center: Point = {\r\n            x: 0.5 * canvasSize[0],\r\n            y: 0.5 * canvasSize[1],\r\n        };\r\n\r\n        const scaling = PRESET_SIZE / Math.min(canvasSize[0], canvasSize[1]);\r\n\r\n        for (const point of points) {\r\n            point.x = 0.5 * PRESET_SIZE + (point.x - center.x) * scaling;\r\n            point.y = 0.5 * PRESET_SIZE + (point.y - center.y) * scaling;\r\n        }\r\n\r\n        Presets.cache[EPreset.CUSTOM] = {\r\n            state: EState.LOADED,\r\n            points,\r\n        };\r\n    }\r\n\r\n    private static cache: {\r\n        [propName: string]: ICachedPreset;\r\n    } = {};\r\n\r\n    private static lastRegisteredCallback: {\r\n        wantedPreset: EPreset;\r\n        wantedWidth: number;\r\n        wantedHeight: number;\r\n        callback: PresetCallback;\r\n    } = null;\r\n\r\n    private static tryCallRegisteredCallback(): void {\r\n        if (Presets.lastRegisteredCallback !== null) {\r\n            const preset = Presets.lastRegisteredCallback.wantedPreset;\r\n            const isPresetLoaded = (typeof Presets.cache[preset] !== \"undefined\") &&\r\n                (Presets.cache[preset].state === EState.LOADED);\r\n\r\n            if (isPresetLoaded) {\r\n                const width = Presets.lastRegisteredCallback.wantedWidth;\r\n                const height = Presets.lastRegisteredCallback.wantedHeight;\r\n\r\n                const stopWatchResize = new StopWatch();\r\n                const resizedPreset = Presets.resizePreset(Presets.cache[preset].points, width, height);\r\n                Log.message(`Resized preset '${preset}' in ${stopWatchResize.milliseconds} ms`);\r\n\r\n                Presets.lastRegisteredCallback.callback(resizedPreset);\r\n                Presets.lastRegisteredCallback = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static resizePreset(points: Point[], width: number, height: number): Point[] {\r\n        const scaling = Math.min(width, height) / PRESET_SIZE;\r\n        const offsetX = 0.5 * (width - PRESET_SIZE * scaling);\r\n        const offsetY = 0.5 * (height - PRESET_SIZE * scaling);\r\n\r\n        /* Create a deep copy to keep the cache clean */\r\n        const copy: Point[] = [];\r\n        for (const point of points) {\r\n            copy.push({\r\n                x: point.x * scaling + offsetX,\r\n                y: point.y * scaling + offsetY,\r\n            });\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n    private static tryParsePointsArray(text: string): Point[] | null {\r\n        if (!text) {\r\n            return null;\r\n        }\r\n\r\n        const points: Point[] = [];\r\n\r\n        const lines: string[] = text.split(\"\\n\");\r\n        for (const line of lines) {\r\n            const partial = line.split(\" \");\r\n            if (partial.length !== 2) {\r\n                return null;\r\n            }\r\n\r\n            points.push({\r\n                x: +partial[0],\r\n                y: +partial[1],\r\n            });\r\n        }\r\n\r\n        if (points.length <= 1) {\r\n            return null;\r\n        }\r\n\r\n        return points;\r\n    }\r\n}\r\n\r\nexport {\r\n    EPreset,\r\n    Presets,\r\n};\r\n","/**\r\n * Class for measuring execution performance.\r\n */\r\nclass StopWatch {\r\n    private readonly start: DOMHighResTimeStamp;\r\n\r\n    public constructor() {\r\n        this.start = performance.now();\r\n    }\r\n\r\n    public get milliseconds(): number {\r\n        return Math.ceil(performance.now() - this.start);\r\n    }\r\n}\r\n\r\nexport {\r\n    StopWatch,\r\n};\r\n","import { Canvas2D } from \"./canvas-2d\";\r\nimport { Point } from \"./point\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\ntype Callback = (isValid: boolean) => unknown;\r\n\r\nlet currentPoints: Point[] = [];\r\nlet isRecordingUserInput = false;\r\nconst finishedAcquisitionCallbacks: Callback[] = [];\r\n\r\nfunction getMousePosition(): Point {\r\n    const canvasSize: number[] = Page.Canvas.getSize();\r\n    const mousePosition: number[] = Page.Canvas.getMousePosition();\r\n    return {\r\n        x: canvasSize[0] * mousePosition[0],\r\n        y: canvasSize[1] * mousePosition[1],\r\n    };\r\n}\r\n\r\nPage.Canvas.Observers.mouseDown.push(() => {\r\n    isRecordingUserInput = true;\r\n    const currentPosition = getMousePosition();\r\n    currentPoints = [currentPosition];\r\n});\r\n\r\nPage.Canvas.Observers.mouseUp.push(() => {\r\n    if (isRecordingUserInput) {\r\n        isRecordingUserInput = false;\r\n\r\n        for (const callback of finishedAcquisitionCallbacks) {\r\n            callback(currentPoints.length >= 2);\r\n        }\r\n    }\r\n});\r\n\r\nPage.Canvas.Observers.mouseMove.push(() => {\r\n    if (isRecordingUserInput) {\r\n        const currentPosition = getMousePosition();\r\n        const isPointFarEnough = Point.distance(currentPoints[currentPoints.length - 1], currentPosition) > 2;\r\n        if (isPointFarEnough) {\r\n            currentPoints.push(currentPosition);\r\n        }\r\n    }\r\n});\r\n\r\nfunction isRecording(): boolean {\r\n    return isRecordingUserInput;\r\n}\r\n\r\nfunction drawCurrentPath(canvas: Canvas2D): void {\r\n    canvas.startLine();\r\n\r\n    for (const point of currentPoints) {\r\n        canvas.addPointToLine(point);\r\n    }\r\n\r\n    canvas.endLine();\r\n}\r\n\r\nexport {\r\n    drawCurrentPath,\r\n    finishedAcquisitionCallbacks,\r\n    isRecording,\r\n    currentPoints as recordedPath,\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(633);\n"],"sourceRoot":""}